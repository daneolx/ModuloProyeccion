






Informe de Componente del Proyecto de Modulo de Dominio para Efecto de la Inflación sobre el Ahorro







Anibal Huaman, Karen Medrano, David Cantorín, Sulmairy Garcia y Diego Arrieta
Escuela de Posgrado, Universidad Continental
PSMA01283: Construcción de Software
Mag. JOEL FERNANDO MACHADO VICENTE








28 de junio del 2025

Fase 1 – Planificación y Diseño
Módulo: Efecto de la Inflación sobre el Ahorro
1.	Selección del dominio y definición del componente
Dominio: Educación financiera / análisis de poder adquisitivo.
Necesidad a resolver: Dado un monto de ahorro nominal, un horizonte temporal (años) y una tasa de inflación anual, calcular:
•	Poder adquisitivo final real del ahorro.
•	Pérdida porcentual acumulada por efecto de la inflación.
Entradas mínimas:
•	Tasa de inflación anual (en %), inflation_rate (p.ej., 6.5)
•	Monto nominal ahorrado, amount_nominal (p.ej., 10,000.00)
•	Tiempo en años (puede ser fraccional), years (p.ej., 3)
Salidas:
•	Valor real final del ahorro (moneda base)
•	Pérdida acumulada en moneda
•	Pérdida acumulada en porcentaje
•	Serie opcional por año (si se activa granularity)
Supuestos: Inflación constante durante el periodo. Extensión futura: curva de inflación año a año.
2.	Diseño de alto nivel
2.1	Definición funcional y fórmulas
Sea A0: monto nominal inicial; π: tasa de inflación anual en decimal (6.5% → 0.065); t: años.
Factor de descuento: D = (1 + π)^t
Valor real final: A_real = A0 / D
Pérdida absoluta: L_abs = A0 − A_real
Pérdida porcentual acumulada: L_% = 1 − 1 / (1 + π)^t
Composición mensual (opcional): (1 + π)^t ≈ (1 + π/12)^(12t)
2.2	Módulos y responsabilidades (Node.js)
• core/calculator.js: funciones puras de cálculo (testables)
• domain/validation.js: validación de entrada con Zod/Joi
• api/effect.controller.js: orquesta validación y cálculo
• api/routes.js: rutas Express (REST)
• server.js: bootstrap y middlewares
• public/: HTML/CSS/JS para UI mínima

Estructura de carpetas sugerida:

project/
  src/
    core/
      calculator.js
      calculator.test.js
    domain/
      validation.js
      validation.test.js
    api/
      effect.controller.js
      routes.js
      effect.api.test.js
    server.js
  public/
    index.html
    app.js
    styles.css
  package.json
  .eslintrc.cjs
  .prettierrc
  .github/workflows/ci.yml

2.3 Contrato de API (JSON)
Request – POST /api/v1/inflation/effect
{
  "amount_nominal": 10000.0,
  "inflation_rate": 6.5,
  "years": 3,
  "granularity": "yearly" // opcional: none|yearly|quarterly
}
Response 200
{
  "amount_nominal": 10000.0,
  "inflation_rate": 6.5,
  "years": 3,
  "real_value": 8256.11,
  "absolute_loss": 1743.89,
  "loss_percent": 17.44,
  "series": [
    {"t": 1, "real_value": 9389.61, "loss_percent": 6.10},
    {"t": 2, "real_value": 8817.57, "loss_percent": 11.82},
    {"t": 3, "real_value": 8256.11, "loss_percent": 17.44}
  ]
}
Response 400 – Validación
{"error": "inflation_rate must be between 0 and 100"}
2.4 Diagrama de secuencia (simplificado)
Usuario → UI(Web): completa formulario y envía
UI(Web) → API: POST /api/v1/inflation/effect (JSON)
API → Validation: validar payload
API → Core Calculator: calcular métricas
Core → API: resultados
API → UI(Web): JSON
UI(Web) → Usuario: muestra tabla y gráfico
2.5 Modelo de datos (opcional)
Tabla calculation_log: id, amount_nominal, inflation_rate, years, computed_at, real_value, loss_percent, user_id (nullable).



3.	Arquitectura sugerida e Infra AWS
Backend: Node.js 20 LTS + Express; Frontend: HTML/CSS/JS; Reverse proxy: Nginx; Proceso: PM2.
Infra mínima viable en AWS:
• EC2 t3.micro/t3.small (Ubuntu 22.04)
• Nginx como reverse proxy (HTTPS con Let’s Encrypt) o ALB + ACM
• S3 (+ CloudFront opcional) para estáticos
• CloudWatch Logs/Alarms
• (Opcional) RDS PostgreSQL si se guarda auditoría
Seguridad y configuración: limitar CORS, validar inputs, headers seguros en Nginx, rotación de logs.
4.	Planificación de pruebas (TDD)
Casos unitarios (core/calculator): zero_inflation, positive_inflation, fractional_years, bounds_validation, large_years.
Pruebas API: 200 con payload válido; 400 con errores detallados; granularity produce serie esperada.
Cobertura objetivo: ≥ 80% en core y ≥ 70% global.
Herramientas: Vitest/Jest + Supertest; ESLint + Prettier; Zod/Joi; c8/nyc para coverage.
5.	Estándares de codificación
JavaScript ES2022+; módulos pequeños; nombres descriptivos; comentarios puntuales.
Conventional Commits (feat:, fix:, test:, refactor:, chore:, docs:).
Lint/format: ESLint + Prettier. Opcional: TypeScript para tipado estático.
6.	Herramientas a utilizar
Gestión de código: Git + GitHub (branches: main, develop, feature/*).
CI/CD (GitHub Actions): jobs lint → test → build → deploy (manual).
Observabilidad: CloudWatch + logs Nginx/PM2. Seguridad: HTTPS, límites de request, sanitización.
7.	Plan de despliegue en AWS
1) Repo con tests pasando.
2) EC2 con Nginx y PM2 como servicio systemd.
3) Dominio en Route 53 y TLS (ACM/ALB o Let’s Encrypt en Nginx).
4) S3 para estáticos (si aplica).
5) Pipeline CI (SSH o SSM) y secretos en SSM Parameter Store.
6) Monitoreo básico (CPU, memoria) y alarmas.
8.	Riesgos y mitigaciones
R1 – Validación inadecuada → Schemas estrictos (Zod/Joi) + pruebas de límites.
R2 – Inconsistencias numéricas → Usar Number seguro; para dinero considerar decimal.js; tolerancias en tests.
R3 – Seguridad → HTTPS forzado, CORS controlado, rate limiting, headers en Nginx.
R4 – Sobre-ingeniería → Core pequeño; posponer persistencia si no la exige la rúbrica.
9.	Cronograma sugerido (3–4 semanas)
Semana 1: Diseño, esqueleto del repo, tests del core, endpoint mock.
Semana 2: Implementación TDD del core + API; UI mínima.
Semana 3: Refactor, análisis estático, documentación técnica, demo.
Semana 4 (buffer): Ajustes finales, presentación, hardening (Nginx, TLS, logs).
10.	Criterios de aceptación (Definition of Done)
• Endpoint POST /api/v1/inflation/effect operativo con validación y pruebas.
• Cobertura mínima: ≥80% core y ≥70% global.
• Documentación: README, contrato API y ejemplos.
• Despliegue en AWS accesible por HTTPS; logs visibles.
11.	Ejemplo numérico (validación rápida)
Entrada: A0=10,000; π=6.5%; t=3. D=(1+0.065)^3=1.2088.
Valor real ≈ 8,256.11; Pérdida absoluta ≈ 1,743.89; Pérdida % ≈ 17.44%.
12.	Bibliografía
• Martin, R. C. Clean Code.
• Fowler, M. Refactoring.
• Kent Beck. Test-Driven Development by Example.
